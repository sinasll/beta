<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>$BLACK Mining</title>
  <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />
  <!-- Telegram WebApp SDK -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <!-- Firebase SDKs (using compat libraries) -->
  <script src="https://www.gstatic.com/firebasejs/11.4.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/11.4.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/11.4.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/11.4.0/firebase-functions-compat.js"></script>
</head>
<body>
  <div class="header">
    <h1 class="logo">$BLACK</h1>
  </div>

  <div class="container">
    <!-- Global Stats -->
    <div class="card global-stats">
      <div class="stats-row">
        <div>Total Mined</div>
        <div><span id="mined">0.00</span> / 100,000,000 $BLACK</div>
      </div>
      <div class="stats-row">
        <div>Total Miners</div>
        <div><span id="totalminers">0</span></div>
      </div>
      <div class="stats-row">
        <div>Active Miners</div>
        <div><span id="activeminers">0</span></div>
      </div>
    </div>

    <!-- User Stats -->
    <div class="card">
      <h2 class="card-title">User</h2>
      <div class="stats-row">
        <div>Username</div>
        <div><span id="username">username</span></div>
      </div>
      <div class="stats-row">
        <div>Balance</div>
        <div><span id="balance">0.000</span> $BLACK</div>
      </div>
      <div class="stats-row">
        <div>Mining Power</div>
        <div>x<span id="power">1.0</span></div>
      </div>
      <div class="stats-row">
        <div>Your Code Submissions</div>
        <div><span id="submissionCount">0</span>/10</div>
      </div>
      <button class="button" id="upgradeButton">Upgrade Power</button>
      <button class="button" id="mineButton">Start Mining</button>
    </div>

    <!-- Daily Code Section -->
    <div class="card">
      <div class="stats-row">
        <h2 class="card-title">Daily Code</h2>
        <div><span id="dailyCode">XXXXXXXXXX</span></div>
      </div>
      <button class="button" id="copyCodeButton">Copy Code</button>
      <input type="text" id="submitCodeInput" placeholder="Enter 10-digit code" maxlength="10" />
      <button class="button" id="submitCodeButton">Submit Code</button>
    </div>

    <div class="countdown" id="countdown">Daily reset in 00:00:00</div>
  </div>

  <!-- Upgrade Power Modal -->
  <div class="modal-overlay" id="upgradeModal">
    <div class="modal">
      <div class="modal-header">
        <h3 class="modal-title">Upgrade Mining Power</h3>
        <button class="modal-close" id="closeModal">&times;</button>
      </div>
      <div class="power-option">
        <div class="power-info">
          <div class="power-name">Advanced Miner</div>
          <div class="power-desc">2x mining acceleration</div>
          <div class="power-price"><i class="fas fa-star"></i> 250 Stars</div>
        </div>
        <button class="power-buy" data-power="2" data-price="250">Upgrade</button>
      </div>
      <div class="power-option premium">
        <div class="power-info">
          <div class="power-badge">RECOMMENDED</div>
          <div class="power-name">Pro Miner</div>
          <div class="power-desc">5x mining acceleration</div>
          <div class="power-price"><i class="fas fa-star"></i> 500 Stars</div>
        </div>
        <button class="power-buy premium-btn" data-power="5" data-price="500">Upgrade</button>
      </div>
      <div class="power-option elite-highlight">
        <div class="elite-glow"></div>
        <div class="power-info">
          <div class="power-name">Elite Miner</div>
          <div class="power-desc">10x mining acceleration</div>
          <div class="power-price"><i class="fas fa-star"></i> 1000 Stars</div>
        </div>
        <button class="power-buy elite-btn" data-power="10" data-price="1000">Upgrade</button>
      </div>
      <div class="power-note">
        <i class="fas fa-info-circle"></i> Higher mining power = More $BLACK per minute
      </div>
    </div>
  </div>

  <!-- Navigation Menu -->
  <nav class="nav-menu" id="nav-menu">
    <ul class="nav-list">
      <li><a href="index.html" class="active">MINE</a></li>
      <li><a href="leaders.html">LEADERS</a></li>
      <li><a href="earn.html">EARN</a></li>
      <li><a href="friends.html">FRIENDS</a></li>
      <li><a href="wallet.html">WALLET</a></li>
    </ul>
  </nav>

  <script>
// Firebase Initialization
const firebaseConfig = {
  apiKey: "AIzaSyAzXSCn_QL2XeyRZD71By443sl4wOtXf2Y",
  authDomain: "pipcore-8844f.firebaseapp.com",
  projectId: "pipcore-8844f",
  storageBucket: "pipcore-8844f.appspot.com",
  messagingSenderId: "921115337984",
  appId: "1:921115337984:web:17161651342ad78017bfe5"
};

// Initialize Firebase
firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();
const auth = firebase.auth();

// DOM Elements
const elements = {
  username: document.getElementById('username'),
  balance: document.getElementById('balance'),
  mined: document.getElementById('mined'),
  totalminers: document.getElementById('totalminers'),
  activeminers: document.getElementById('activeminers'),
  power: document.getElementById('power'),
  submissionCount: document.getElementById('submissionCount'),
  dailyCode: document.getElementById('dailyCode'),
  mineButton: document.getElementById('mineButton'),
  submitCodeButton: document.getElementById('submitCodeButton'),
  submitCodeInput: document.getElementById('submitCodeInput'),
  copyCodeButton: document.getElementById('copyCodeButton'),
  upgradeButton: document.getElementById('upgradeButton'),
  countdown: document.getElementById('countdown')
};

// Global Variables
let currentUserRef = null;
let userData = null;
let miningInterval = null;
const baseMiningRate = 0.003472; // ~5 tokens per day at 1x power
const globalStatsRef = db.collection('stats').doc('global');

// Utility Functions
function generateDailyCode() {
  return Math.floor(1000000000 + Math.random() * 9000000000).toString();
}

function getTimestamp(timestamp) {
  if (!timestamp) return new Date();
  if (timestamp.toDate) return timestamp.toDate();
  if (timestamp.seconds) return new Date(timestamp.seconds * 1000);
  return new Date(timestamp);
}

function isWithin24Hours(timestamp) {
  const date = getTimestamp(timestamp);
  return Date.now() - date.getTime() < 24 * 60 * 60 * 1000;
}

function formatTime(ms) {
  const seconds = Math.floor((ms / 1000) % 60);
  const minutes = Math.floor((ms / (1000 * 60)) % 60);
  const hours = Math.floor((ms / (1000 * 60 * 60)) % 24);
  return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}

// Initialize Global Stats
async function initializeGlobalStats() {
  const doc = await globalStatsRef.get();
  if (!doc.exists) {
    await globalStatsRef.set({
      totalSupply: 0,
      totalMiners: 0,
      activeMiners: 0,
      lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
    });
  }
}

// Stats Management
async function updateStats(activeChange = 0, minedChange = 0, minerChange = 0) {
  try {
    const updates = {};
    if (activeChange !== 0) updates.activeMiners = firebase.firestore.FieldValue.increment(activeChange);
    if (minedChange !== 0) updates.totalSupply = firebase.firestore.FieldValue.increment(minedChange);
    if (minerChange !== 0) updates.totalMiners = firebase.firestore.FieldValue.increment(minerChange);
    
    if (Object.keys(updates).length > 0) {
      await globalStatsRef.update(updates);
    }
  } catch (error) {
    console.error("Error updating stats:", error);
    if (error.code === 'not-found') {
      await initializeGlobalStats();
      await updateStats(activeChange, minedChange, minerChange);
    }
  }
}

// Mining Functions
function calculateEarnings() {
  if (!userData?.mining) return 0;
  const now = Date.now();
  const lastUpdate = getTimestamp(userData.lastMiningUpdate).getTime();
  const elapsed = (now - lastUpdate) / 1000;
  const effectivePower = userData.miningPower + 
                        (userData.hasSubmittedToday ? 0.5 : 0) + 
                        (userData.submissionsReceived || 0) * 0.1;
  return (baseMiningRate * effectivePower * elapsed) / 60;
}

async function startMining() {
  if (miningInterval) clearInterval(miningInterval);
  
  elements.mineButton.textContent = "Mining...";
  
  // Process any pending earnings
  const pendingEarnings = calculateEarnings();
  if (pendingEarnings > 0) {
    await currentUserRef.update({
      balance: firebase.firestore.FieldValue.increment(pendingEarnings),
      lastMiningUpdate: firebase.firestore.FieldValue.serverTimestamp()
    });
    await updateStats(0, pendingEarnings);
  }
  
  // Start new interval
  miningInterval = setInterval(async () => {
    const earned = calculateEarnings();
    if (earned > 0) {
      try {
        await currentUserRef.update({
          balance: firebase.firestore.FieldValue.increment(earned),
          lastMiningUpdate: firebase.firestore.FieldValue.serverTimestamp()
        });
        await updateStats(0, earned);
      } catch (error) {
        console.error("Mining error:", error);
      }
    }
  }, 1000);
  
  await updateStats(1); // Increment active miners
}

async function stopMining() {
  if (miningInterval) {
    clearInterval(miningInterval);
    miningInterval = null;
    elements.mineButton.textContent = "Start Mining";
    await updateStats(-1); // Decrement active miners
    
    // Process any pending earnings
    const pendingEarnings = calculateEarnings();
    if (pendingEarnings > 0) {
      await currentUserRef.update({
        balance: firebase.firestore.FieldValue.increment(pendingEarnings),
        lastMiningUpdate: firebase.firestore.FieldValue.serverTimestamp()
      });
      await updateStats(0, pendingEarnings);
    }
  }
}

// User Management
async function initializeUser(user) {
  currentUserRef = db.collection('users').doc(user.uid);
  
  const doc = await currentUserRef.get();
  if (!doc.exists) {
    // New user setup
    const initialData = {
      username: Telegram?.WebApp?.initDataUnsafe?.user?.username || 'Anonymous',
      balance: 0,
      miningPower: 1.0,
      dailyCode: generateDailyCode(),
      codeTimestamp: firebase.firestore.FieldValue.serverTimestamp(),
      submissionsReceived: 0,
      hasSubmittedToday: false,
      mining: false,
      lastMiningUpdate: firebase.firestore.FieldValue.serverTimestamp(),
      stars: 0
    };
    
    await currentUserRef.set(initialData);
    await updateStats(0, 0, 1); // Increment total miners
    userData = initialData;
    updateUI();
  } else {
    userData = doc.data();
    
    // Daily reset logic
    if (!userData.codeTimestamp || !isWithin24Hours(userData.codeTimestamp)) {
      await currentUserRef.update({
        dailyCode: generateDailyCode(),
        codeTimestamp: firebase.firestore.FieldValue.serverTimestamp(),
        submissionsReceived: 0,
        hasSubmittedToday: false
      });
    }
    
    updateUI();
    
    // Start mining if active
    if (userData.mining) {
      await startMining();
    }
  }
  
  // Setup real-time listener for user data
  currentUserRef.onSnapshot((doc) => {
    userData = doc.data();
    updateUI();
  });
}

// Code Submission
async function submitCode(code) {
  try {
    // Validate input
    if (!code.match(/^\d{10}$/)) {
      alert("Please enter a valid 10-digit code");
      return;
    }
    
    if (userData.hasSubmittedToday) {
      alert("You've already submitted a code today");
      return;
    }
    
    if (code === userData.dailyCode) {
      alert("You can't submit your own code");
      return;
    }
    
    // Find code owner
    const querySnapshot = await db.collection('users')
      .where('dailyCode', '==', code)
      .limit(1)
      .get();
    
    if (querySnapshot.empty) {
      alert("Invalid code - not found in system");
      return;
    }
    
    const codeOwnerDoc = querySnapshot.docs[0];
    const codeOwnerRef = codeOwnerDoc.ref;
    const codeOwnerData = codeOwnerDoc.data();
    
    // Validate code
    if (!codeOwnerData.codeTimestamp || !isWithin24Hours(codeOwnerData.codeTimestamp)) {
      alert("This code has expired (older than 24 hours)");
      return;
    }
    
    if (codeOwnerData.submissionsReceived >= 10) {
      alert("This code has reached its maximum submissions (10)");
      return;
    }
    
    // Create batch for atomic updates
    const batch = db.batch();
    
    // Update code owner
    batch.update(codeOwnerRef, {
      submissionsReceived: firebase.firestore.FieldValue.increment(1)
    });
    
    // Update current user
    batch.update(currentUserRef, {
      hasSubmittedToday: true,
      miningPower: firebase.firestore.FieldValue.increment(0.5)
    });
    
    // Update global stats with bonus
    batch.update(globalStatsRef, {
      totalSupply: firebase.firestore.FieldValue.increment(50)
    });
    
    // Commit the batch
    await batch.commit();
    
    alert("Code submitted successfully! You received +0.5x mining power");
    elements.submitCodeInput.value = '';
  } catch (error) {
    console.error("Error submitting code:", error);
    alert("An error occurred while submitting the code");
  }
}

// UI Functions
function updateUI() {
  if (!userData) return;
  
  // Update user stats
  elements.balance.textContent = userData.balance.toFixed(3);
  elements.username.textContent = userData.username;
  elements.dailyCode.textContent = userData.dailyCode;
  elements.submissionCount.textContent = userData.submissionsReceived || 0;
  
  // Calculate effective power
  const effectivePower = userData.miningPower + 
                        (userData.hasSubmittedToday ? 0.5 : 0) + 
                        (userData.submissionsReceived || 0) * 0.1;
  elements.power.textContent = effectivePower.toFixed(1);
  
  // Update mining button
  elements.mineButton.textContent = userData.mining ? "Mining..." : "Start Mining";
  
  // Update countdown timer
  updateCountdown();
}

function updateCountdown() {
  if (!userData?.codeTimestamp) {
    elements.countdown.textContent = "Daily reset in --:--:--";
    return;
  }
  
  try {
    const resetTime = getTimestamp(userData.codeTimestamp).getTime() + 24 * 60 * 60 * 1000;
    const remaining = resetTime - Date.now();
    elements.countdown.textContent = remaining > 0 
      ? `Daily reset in ${formatTime(remaining)}` 
      : "Daily reset pending...";
  } catch (error) {
    console.error("Countdown error:", error);
    elements.countdown.textContent = "Daily reset in --:--:--";
  }
}

// Event Listeners
function setupEventListeners() {
  elements.mineButton.addEventListener('click', async () => {
    if (!currentUserRef) return;
    
    try {
      await currentUserRef.update({
        mining: !userData.mining,
        lastMiningUpdate: firebase.firestore.FieldValue.serverTimestamp()
      });
    } catch (error) {
      console.error("Error toggling mining:", error);
    }
  });

  elements.submitCodeButton.addEventListener('click', () => {
    const code = elements.submitCodeInput.value.trim();
    submitCode(code);
  });

  elements.copyCodeButton.addEventListener('click', () => {
    navigator.clipboard.writeText(userData.dailyCode)
      .then(() => alert('Daily code copied to clipboard!'))
      .catch(() => alert('Failed to copy code'));
  });

  elements.upgradeButton.addEventListener('click', () => {
    document.getElementById('upgradeModal').style.display = 'flex';
  });

  document.getElementById('closeModal').addEventListener('click', () => {
    document.getElementById('upgradeModal').style.display = 'none';
  });

  // Power upgrade handlers
  document.querySelectorAll('.power-buy').forEach(button => {
    button.addEventListener('click', async (e) => {
      const power = parseFloat(e.target.dataset.power);
      const price = parseInt(e.target.dataset.price);
      
      if (userData.stars < price) {
        alert(`You need ${price} stars to upgrade to this power level`);
        return;
      }
      
      try {
        await currentUserRef.update({
          miningPower: power,
          stars: firebase.firestore.FieldValue.increment(-price)
        });
        alert(`Upgraded to ${power}x mining power!`);
        document.getElementById('upgradeModal').style.display = 'none';
      } catch (error) {
        console.error("Upgrade failed:", error);
        alert("Upgrade failed. Please try again.");
      }
    });
  });
}

// Global Stats Listener
function setupStatsListener() {
  globalStatsRef.onSnapshot((doc) => {
    const stats = doc.data();
    if (stats) {
      elements.mined.textContent = (stats.totalSupply || 0).toFixed(2);
      elements.totalminers.textContent = stats.totalMiners || 0;
      elements.activeminers.textContent = stats.activeMiners || 0;
    }
  });
}

// Initialize App
async function initializeApp() {
  try {
    await initializeGlobalStats();
    await auth.signInAnonymously();
    setupEventListeners();
    setupStatsListener();
    setInterval(updateCountdown, 1000);
  } catch (error) {
    console.error("App initialization error:", error);
  }
}

// Handle page visibility changes
document.addEventListener('visibilitychange', async () => {
  if (document.visibilityState === 'visible' && userData?.mining) {
    // Recalculate earnings when tab becomes active again
    const earned = calculateEarnings();
    if (earned > 0) {
      await currentUserRef.update({
        balance: firebase.firestore.FieldValue.increment(earned),
        lastMiningUpdate: firebase.firestore.FieldValue.serverTimestamp()
      });
      await updateStats(0, earned);
    }
  }
});

// Cleanup on page unload
window.addEventListener('beforeunload', async () => {
  if (userData?.mining) {
    // Process any pending earnings
    const earned = calculateEarnings();
    if (earned > 0) {
      await currentUserRef.update({
        balance: firebase.firestore.FieldValue.increment(earned),
        lastMiningUpdate: firebase.firestore.FieldValue.serverTimestamp()
      });
      await updateStats(0, earned);
    }
    
    // Decrement active miners count
    await updateStats(-1);
  }
});

// Auth State Listener
auth.onAuthStateChanged((user) => {
  if (user) {
    initializeUser(user);
  } else {
    console.log("User not authenticated");
  }
});

// Start the application
initializeApp();
  </script>
</body>
</html>
