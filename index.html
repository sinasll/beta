<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>$BLACK Mining</title>
  <style>
    :root {
      --tg-theme-bg-color: #070606;
      --tg-theme-text-color: #ffffff;
      --tg-theme-hint-color: #7f8c8d;
      --tg-theme-link-color: #3a7bd5;
      --tg-theme-button-color: #3a7bd5;
      --tg-theme-button-text-color: #ffffff;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans, Ubuntu, Cantarell, sans-serif;
      background: var(--tg-theme-bg-color);
      color: var(--tg-theme-text-color);
      margin: 0;
      padding: 0;
      max-width: 100%;
      overflow-x: hidden;
    }
    /* Professional UI components */
    .container { padding: 16px; max-width: 500px; margin: 0 auto; }
    .card { background: rgba(255,255,255,0.1); border-radius: 16px; padding: 20px; margin-bottom: 16px; }
    .progress-bar { height: 8px; background: rgba(255,255,255,0.2); border-radius: 4px; overflow: hidden; }
    .progress { height: 100%; background: var(--tg-theme-button-color); transition: width 0.3s; }
    .button { display: block; width: 100%; padding: 12px; border-radius: 12px; background: var(--tg-theme-button-color); color: var(--tg-theme-button-text-color); text-align: center; font-weight: 500; border: none; }
  </style>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>
</head>
<body>
  <div class="container">
    <div class="card">
      <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
        <div>Total Supply</div>
        <div>125,000,000</div>
      </div>
      <div class="progress-bar">
        <div class="progress" id="progress"></div>
      </div>
      <div style="text-align: right; margin-top: 8px; font-size: 0.9em;">
        Mined: <span id="mined">0.00</span>
      </div>
    </div>

    <div class="card">
      <h2 style="margin: 0 0 16px 0;">Your Account</h2>
      <div style="margin-bottom: 12px;">@<span id="username">loading...</span></div>
      <div style="display: flex; justify-content: space-between;">
        <div>Balance</div>
        <div><span id="balance">0.00</span> $BLACK</div>
      </div>
      <div style="display: flex; justify-content: space-between; margin-top: 8px;">
        <div>Mining Power</div>
        <div><span id="power">1.0</span>x</div>
      </div>
      <div id="countdownTimer" style="display: none; margin-top: 8px; text-align: center;"></div>
    </div>

    <button class="button" id="mineButton" onclick="app.toggleMining()">Start Mining</button>
  </div>

  <script>
// ======================
// 1. Configuration
// ======================
const ENV = {
  BASE_RATE: 0.003472 / 6 // 0.02/hour
};

// ======================
// 2. Firebase Setup
// ======================
const firebaseConfig = {
  apiKey: "AIzaSyAzXSCn_QL2XeyRZD71By443sl4wOtXf2Y",
  authDomain: "pipcore-8844f.firebaseapp.com",
  projectId: "pipcore-8844f",
  storageBucket: "pipcore-8844f.appspot.com",
  messagingSenderId: "921115337984",
  appId: "1:921115337984:web:17161651342ad78017bfe5"
};

firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();
let userRef, unsubscribeUser;

// ======================
// 3. Core Application
// ======================
class MiningApp {
  constructor() {
    this.userId = null;
    this.miningInterval = null;
    this.countdownInterval = null;
    this.init();
  }

  async init() {
    try {
      // Initialize Telegram WebApp
      Telegram.WebApp.ready();
      Telegram.WebApp.expand();

      // Get and verify Telegram user
      const tgUser = Telegram.WebApp.initDataUnsafe.user;
      if (!tgUser?.id) throw new Error("Invalid Telegram user");

      // Initialize user session
      await this.initUserSession(tgUser);

      // Setup real-time listener
      this.setupRealtimeUpdates();

      // Handle visibility changes
      document.addEventListener('visibilitychange', this.handleVisibilityChange);

    } catch (error) {
      console.error("App initialization failed:", error);
      this.showError("Failed to initialize. Please restart the app.");
    }
  }

  async initUserSession(tgUser) {
    this.userId = `tg_${tgUser.id}`;
    userRef = db.collection('users').doc(this.userId);

    const userData = {
      telegramId: tgUser.id,
      username: tgUser.username || `user_${tgUser.id}`,
      firstName: tgUser.first_name,
      lastName: tgUser.last_name || '',
      balance: 0,
      miningPower: 1,
      miningActive: false,
      lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
    };

    await db.runTransaction(async (transaction) => {
      const doc = await transaction.get(userRef);
      if (!doc.exists) {
        transaction.set(userRef, {
          ...userData,
          joinedAt: firebase.firestore.FieldValue.serverTimestamp()
        });
      }
    });
  }

  setupRealtimeUpdates() {
    unsubscribeUser = userRef.onSnapshot(async (doc) => {
      const data = doc.data() || {};
      this.updateUI(data);

      if (data.miningActive && !this.miningInterval) {
        this.startMiningEngine();
        this.startCountdown();  // Start the countdown timer when mining starts
      }
    }, error => {
      console.error("Realtime update error:", error);
      this.showError("Connection lost. Reconnecting...");
    });
  }

  // ======================
  // 4. Mining System
  // ======================
  async startMining() {
    const doc = await userRef.get();
    const data = doc.data();

    if (data.miningActive) {
      // Mining is already active, do nothing.
      return;
    } else {
      // Start mining
      await userRef.update({
        miningActive: true
      });
      this.startMiningEngine();
      this.startCountdown();  // Start the countdown when mining starts
    }
  }

  startMiningEngine() {
    this.miningInterval = setInterval(async () => {
      const doc = await userRef.get();
      const data = doc.data();
      const earnings = ENV.BASE_RATE * this.calculatePower(data);

      await userRef.update({
        balance: firebase.firestore.FieldValue.increment(earnings),
        lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
      });
    }, 10000);
  }

  calculatePower(data) {
    // Basic power calculation; extend this function if more factors are needed.
    return 1 + (data.premium ? 0.5 : 0);
  }

  // ======================
  // 5. UI Management
  // ======================
  updateUI(data) {
    document.getElementById('username').textContent = data.username;
    document.getElementById('balance').textContent = data.balance.toFixed(2);
    document.getElementById('power').textContent = this.calculatePower(data).toFixed(1);

    // The mining button should always say "Mining Active" if mining is active
    const mineButton = document.getElementById('mineButton');
    mineButton.textContent = data.miningActive ? "Mining Active" : "Start Mining";
  }

  showError(message) {
    Telegram.WebApp.showAlert(message);
  }

  handleVisibilityChange = () => {
    if (document.visibilityState === 'hidden') {
      clearInterval(this.miningInterval);
      this.miningInterval = null;
      this.stopCountdown();
    } else {
      userRef.get().then(doc => {
        if (doc.exists && doc.data().miningActive && !this.miningInterval) {
          this.startMiningEngine();
          this.startCountdown(); // Restart countdown if mining is active
        }
      });
    }
  }

  // ======================
  // 6. Countdown Timer
  // ======================
  startCountdown() {
    const countdownElement = document.getElementById('countdownTimer');
    countdownElement.style.display = 'block';

    const updateCountdown = () => {
      const now = new Date();
      const utcNow = new Date(now.getTime() + now.getTimezoneOffset() * 60000);
      const targetTime = new Date(utcNow);
      targetTime.setUTCHours(23, 59, 59, 999);

      const timeDifference = targetTime - utcNow;

      if (timeDifference > 0) {
        const hours = Math.floor((timeDifference / (1000 * 60 * 60)) % 24);
        const minutes = Math.floor((timeDifference / (1000 * 60)) % 60);
        const seconds = Math.floor((timeDifference / 1000) % 60);

        const formattedTime = `${hours.toString().padStart(2, '0')}:` +
                              `${minutes.toString().padStart(2, '0')}:` +
                              `${seconds.toString().padStart(2, '0')}`;

        countdownElement.textContent = `Mining stops in ${formattedTime}`;
      } else {
        countdownElement.textContent = "Mining has stopped.";
        clearInterval(this.countdownInterval);
        this.restartMining();  // Restart mining when the day ends
      }
    };

    updateCountdown();
    this.countdownInterval = setInterval(updateCountdown, 1000);
  }

  stopCountdown() {
    clearInterval(this.countdownInterval);
    const countdownElement = document.getElementById('countdownTimer');
    countdownElement.style.display = 'none';
  }

  restartMining() {
    // Automatically restart mining at 00:00 UTC
    const now = new Date();
    const utcNow = new Date(now.getTime() + now.getTimezoneOffset() * 60000);
    const targetTime = new Date(utcNow);
    targetTime.setUTCHours(0, 0, 0, 0); // Target time at 00:00 UTC of the next day

    // Calculate time until the next mining day
    const timeUntilNextDay = targetTime - utcNow;

    setTimeout(() => {
      this.startMining();  // Start mining again when the new day begins
    }, timeUntilNextDay);
  }

  // ======================
  // 7. Cleanup
  // ======================
  destroy() {
    clearInterval(this.miningInterval);
    clearInterval(this.countdownInterval);
    if (unsubscribeUser) unsubscribeUser();
    document.removeEventListener('visibilitychange', this.handleVisibilityChange);
  }
}

// Initialize application
let app;
document.addEventListener('DOMContentLoaded', () => app = new MiningApp());
window.addEventListener('beforeunload', () => app.destroy());

// ======================
// 8. Global Mined Tokens Tracker
// ======================
// Listen for changes on the entire "users" collection and sum the balance values.
db.collection('users').onSnapshot(snapshot => {
  let totalMined = 0;
  snapshot.forEach(doc => {
    const data = doc.data();
    totalMined += data.balance;
  });
  document.getElementById('mined').textContent = totalMined.toFixed(2);
  const progress = (totalMined / 125000000) * 100;
  document.getElementById('progress').style.width = `${progress}%`;
});

    </script>
    
</body>
</html>
